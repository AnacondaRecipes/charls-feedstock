From a80b8ee9acd127034cf492de3621a71e265202cd Mon Sep 17 00:00:00 2001
From: Victor Derks <vbaderks@gmail.com>
Date: Thu, 2 Jan 2020 00:53:30 +0100
Subject: [PATCH] Improve the compatibility with VS 2015

Visual Studio 2015 is mostly C++14 compatible, but some constexpr constructions are not supported.  Add a helper macro to make it possible to use VS2015  to compile CharLS 2.1.0. See also #60
---
 CHANGELOG.md                |  6 ++++++
 include/charls/charls.h     |  2 +-
 src/scan.h                  |  4 ++--
 src/util.h                  | 11 ++++++++++-
 test/portable_anymap_file.h | 17 ++++++++++++++++-
 5 files changed, 35 insertions(+), 5 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index d39a787..4383e94 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,12 @@ All notable changes to this project will be documented in this file.
 
 The format is based on [Keep a Changelog](http://keepachangelog.com/) and this project adheres to [Semantic Versioning](http://semver.org/).
 
+## [Next-Release]
+
+### Fixed
+
+- Fixed [#60](https://github.com/team-charls/charls/issues/60), Visual Studio 2015 C++ compiler cannot compile certain constexpr constructions
+
 ## [2.1.0] - 2019-12-29
 
 ### Added
diff --git a/include/charls/charls.h b/include/charls/charls.h
index f1ef4b3..48046b3 100644
--- a/include/charls/charls.h
+++ b/include/charls/charls.h
@@ -485,7 +485,7 @@ class jpegls_decoder final
         spiff_header header{};
         int32_t found;
         ec = charls_jpegls_decoder_read_spiff_header(decoder_.get(), &header, &found);
-        header_found = static_cast<bool>(found);
+        header_found = header_found = found != 0;
         return header;
     }
 
diff --git a/src/scan.h b/src/scan.h
index 8b943a6..1267284 100644
--- a/src/scan.h
+++ b/src/scan.h
@@ -77,13 +77,13 @@ inline int32_t GetPredictedValue(int32_t Ra, int32_t Rb, int32_t Rc) noexcept
 
 #endif
 
-constexpr int32_t UnMapErrVal(int32_t mappedError) noexcept
+CONSTEXPR int32_t UnMapErrVal(int32_t mappedError) noexcept
 {
     const int32_t sign = mappedError << (int32_t_bit_count - 1) >> (int32_t_bit_count - 1);
     return sign ^ (mappedError >> 1);
 }
 
-constexpr int32_t GetMappedErrVal(int32_t errorValue) noexcept
+CONSTEXPR int32_t GetMappedErrVal(int32_t errorValue) noexcept
 {
     const int32_t mappedError = (errorValue >> (int32_t_bit_count - 2)) ^ (2 * errorValue);
     return mappedError;
diff --git a/src/util.h b/src/util.h
index f12e013..f69a40e 100644
--- a/src/util.h
+++ b/src/util.h
@@ -34,9 +34,18 @@
     __pragma(warning(disable                             \
                      : x)) // NOLINT(misc-macro-parentheses, bugprone-macro-parentheses)
 #define MSVC_WARNING_UNSUPPRESS() __pragma(warning(pop))
+
+// Visual Studio 2015 supports C++14, but not all constexpr scenarios. VS 2017 has full C++14 support.
+#if _MSC_VER >= 1910
+#define CONSTEXPR constexpr
+#else
+#define CONSTEXPR inline
+#endif
+
 #else
 #define MSVC_WARNING_SUPPRESS(x)
 #define MSVC_WARNING_UNSUPPRESS()
+#define CONSTEXPR constexpr
 #endif
 
 namespace charls {
@@ -116,7 +125,7 @@ inline void push_back(std::vector<uint8_t>& values, uint32_t value)
 }
 
 
-constexpr int32_t log_2(int32_t n) noexcept
+CONSTEXPR int32_t log_2(int32_t n) noexcept
 {
     int32_t x = 0;
     while (n > (1 << x))
diff --git a/test/portable_anymap_file.h b/test/portable_anymap_file.h
index 556b417..bd1f20e 100644
--- a/test/portable_anymap_file.h
+++ b/test/portable_anymap_file.h
@@ -9,6 +9,21 @@
 #include <string>
 #include <vector>
 
+
+// Visual Studio 2015 supports C++14, but not all constexpr scenarios. VS 2017 has full C++14 support.
+#ifdef _MSC_VER
+
+#if _MSC_VER >= 1910
+#define CONSTEXPR constexpr
+#else
+#define CONSTEXPR
+#endif
+
+#else
+#define CONSTEXPR constexpr
+#endif
+
+
 namespace charls_test {
 
 // Purpose: this class can read an image stored in the Portable Anymap Format (PNM).
@@ -101,7 +116,7 @@ class portable_anymap_file final
         return result;
     }
 
-    static constexpr int32_t log_2(int32_t n) noexcept
+    static CONSTEXPR int32_t log_2(int32_t n) noexcept
     {
         int32_t x = 0;
         while (n > (1 << x))
